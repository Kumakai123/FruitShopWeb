package org.xiangan.fruitshopweb.service;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DuplicateKeyException;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.xiangan.fruitshopweb.entity.Consignor;import org.xiangan.fruitshopweb.entity.Consignor_;import org.xiangan.fruitshopweb.repository.ConsignorRepository;import java.util.NoSuchElementException;import java.util.Objects;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * (服務層) 貨主 */@Service@Slf4jpublic class ConsignorService {		@Autowired	private ConsignorRepository consignorRepository;		/**	 * @param phoneNumber 連絡電話	 * @param company 公司行號/統編	 * @return 是否有符合連絡電話、公司行號/統編的貨主	 */	@Async	@Transactional(readOnly = true)	public CompletableFuture<Boolean> exist(		final String phoneNumber,		final String company	) {		return CompletableFuture.completedFuture(			consignorRepository				.exists(					(root, criteriaQuery, criteriaBuilder) ->						criteriaBuilder.and(							criteriaBuilder.equal(root.get(Consignor_.phoneNumber), phoneNumber),							criteriaBuilder.equal(root.get(Consignor_.company), company)						)				)		);			}		/**	 * @param id 主鍵	 * @param phoneNumber 連絡電話	 * @param company 公司行號/統編	 * @return 是否有符合連絡主鍵、電話、公司行號/統編的貨主	 */	@Async	@Transactional(readOnly = true)	public CompletableFuture<Boolean> exist(		final long id,		final String phoneNumber,		final String company	) {		return CompletableFuture.completedFuture(			consignorRepository				.exists(					(root, criteriaQuery, criteriaBuilder) ->						criteriaBuilder.and(							criteriaBuilder.not(								criteriaBuilder.equal(root.get(Consignor_.id), id)							),							criteriaBuilder.equal(root.get(Consignor_.phoneNumber), phoneNumber),							criteriaBuilder.equal(root.get(Consignor_.company), company)						)				)		);			}		/**	 * @param id 主鍵	 * @return 貨主	 */	@Async	@Transactional(readOnly = true)	public CompletableFuture<Consignor> load(final long id) {		return CompletableFuture.completedFuture(			consignorRepository				.findById(id)				.orElseThrow(					() -> new NoSuchElementException(						String.format(							"無主鍵為「%d」的貨主❗️",							id						)					)				)		);	}		/**	 * @param p 頁數	 * @param s 一頁幾筆	 * @return 可分頁的貨主們	 */	@Async	@Transactional(readOnly = true)	public CompletableFuture<Page<Consignor>> load(final int p, final int s) {		return CompletableFuture.completedFuture(			consignorRepository				.findAll(					(root, criteriaQuery, criteriaBuilder) -> {						criteriaQuery.orderBy(							criteriaBuilder.asc(root.get(Consignor_.NICK_NAME)),							criteriaBuilder.asc(root.get(Consignor_.NAME)),							criteriaBuilder.asc(root.get(Consignor_.id))						);						return criteriaBuilder.conjunction();					},					PageRequest.of(p, s)				)		);	}		/**	 * @param entity 貨主	 * @return 持久化貨主	 */	@Async	@Transactional	public CompletableFuture<Consignor> save(final Consignor entity) {		final Long id = entity.getId();		final String company = entity.getCompany();		final String phoneNumber = entity.getPhoneNumber();				try {			if (Objects.isNull(id)) {				if (exist(phoneNumber, company).get()) {					throw new DuplicateKeyException(						String.format(							"已有重複的貨主電話：%s❗️",							phoneNumber						)					);				}			} else {				if (exist(id,phoneNumber,company).get()) {					throw new DuplicateKeyException(						String.format(							"已有重複的貨主電話：%s❗️",							phoneNumber						)					);				}			}		} catch (InterruptedException | ExecutionException exception) {			throw new RuntimeException(				String.format(					"讀取是否有重複的貨主時發生線程中斷異常：%s❗️",					exception.getLocalizedMessage()				),				exception			);		}				try {			return CompletableFuture.completedFuture(				consignorRepository.saveAndFlush(entity)			);		} catch (Exception exception) {			throw new RuntimeException(				String.format(					"持久化貨主時拋出線程中斷異常：%s❗️",					exception.getLocalizedMessage()				),				exception			);		}	}		/**	 * @param entity 貨主	 * @return 是否刪除成功	 */	@Async	@Transactional	public CompletableFuture<Boolean> delete(final Consignor entity) {		try {			consignorRepository.delete(entity);		} catch (Exception exception) {			throw new RuntimeException(				String.format(					"刪除貨主「%s%s」時拋出異常：%s❗️",					entity.getNickName(),					entity.getName(),					exception.getLocalizedMessage()				),				exception			);		}				return CompletableFuture.completedFuture(true);	}}